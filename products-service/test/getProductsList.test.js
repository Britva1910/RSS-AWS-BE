"use strict";
const { handler } = require("../lambda-functions/getProductsList");
const { products } = require("../lambda-functions/products");
jest.mock("../lambda-functions/products", () => ({
    products: [],
}));
describe("Get product by ID - getProductById", () => {
    beforeEach(() => {
        jest.resetAllMocks();
    });
    test("should return 200 and the product when a valid ID is provided", async () => {
        const mockProducts = [{ id: "1", title: "Product 1", price: 100 }];
        products.length = 0;
        products.push(...mockProducts);
        const event = {
            pathParameters: {
                id: "1",
            },
        };
        const response = await handler(event);
        expect(response.statusCode).toBe(200);
        expect(response.headers["Content-Type"]).toBe("application/json");
        expect(response.body).toBe(JSON.stringify([{ id: "1", title: "Product 1", price: 100 }]));
    });
    test("should return 400 if product is not found", async () => {
        products.length = 0;
        const event = {
            pathParameters: {
                id: "1",
            },
        };
        const response = await handler(event);
        expect(response.statusCode).toBe(400);
        expect(response.headers["Content-Type"]).toBe("application/json");
        expect(response.body).toBe(JSON.stringify({ message: "Products not found" }));
    });
    test("should return 400 if no products data exists", async () => {
        products.length = 0;
        const event = {
            pathParameters: {
                id: "",
            },
        };
        const response = await handler(event);
        expect(response.statusCode).toBe(400);
        expect(response.headers["Content-Type"]).toBe("application/json");
        expect(response.body).toBe(JSON.stringify({ message: "Products not found" }));
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2V0UHJvZHVjdHNMaXN0LnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJnZXRQcm9kdWN0c0xpc3QudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsTUFBTSxFQUFFLE9BQU8sRUFBRSxHQUFHLE9BQU8sQ0FBQyxxQ0FBcUMsQ0FBQyxDQUFDO0FBQ25FLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxPQUFPLENBQUMsOEJBQThCLENBQUMsQ0FBQztBQUU3RCxJQUFJLENBQUMsSUFBSSxDQUFDLDhCQUE4QixFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDL0MsUUFBUSxFQUFFLEVBQUU7Q0FDYixDQUFDLENBQUMsQ0FBQztBQUVKLFFBQVEsQ0FBQyxvQ0FBb0MsRUFBRSxHQUFHLEVBQUU7SUFDbEQsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDLENBQUMsQ0FBQztJQUVILElBQUksQ0FBQywrREFBK0QsRUFBRSxLQUFLLElBQUksRUFBRTtRQUMvRSxNQUFNLFlBQVksR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO1FBRW5FLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQztRQUUvQixNQUFNLEtBQUssR0FBRztZQUNaLGNBQWMsRUFBRTtnQkFDZCxFQUFFLEVBQUUsR0FBRzthQUNSO1NBQ0YsQ0FBQztRQUVGLE1BQU0sUUFBUSxHQUFHLE1BQU0sT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXRDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDbEUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQ3hCLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUM5RCxDQUFDO0lBQ0osQ0FBQyxDQUFDLENBQUM7SUFFSCxJQUFJLENBQUMsMkNBQTJDLEVBQUUsS0FBSyxJQUFJLEVBQUU7UUFDM0QsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7UUFFcEIsTUFBTSxLQUFLLEdBQUc7WUFDWixjQUFjLEVBQUU7Z0JBQ2QsRUFBRSxFQUFFLEdBQUc7YUFDUjtTQUNGLENBQUM7UUFFRixNQUFNLFFBQVEsR0FBRyxNQUFNLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV0QyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN0QyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUN4QixJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLENBQUMsQ0FDbEQsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLDhDQUE4QyxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQzlELFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBRXBCLE1BQU0sS0FBSyxHQUFHO1lBQ1osY0FBYyxFQUFFO2dCQUNkLEVBQUUsRUFBRSxFQUFFO2FBQ1A7U0FDRixDQUFDO1FBRUYsTUFBTSxRQUFRLEdBQUcsTUFBTSxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdEMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUNsRSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FDeEIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxDQUFDLENBQ2xELENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBoYW5kbGVyIH0gPSByZXF1aXJlKFwiLi4vbGFtYmRhLWZ1bmN0aW9ucy9nZXRQcm9kdWN0c0xpc3RcIik7XHJcbmNvbnN0IHsgcHJvZHVjdHMgfSA9IHJlcXVpcmUoXCIuLi9sYW1iZGEtZnVuY3Rpb25zL3Byb2R1Y3RzXCIpO1xyXG5cclxuamVzdC5tb2NrKFwiLi4vbGFtYmRhLWZ1bmN0aW9ucy9wcm9kdWN0c1wiLCAoKSA9PiAoe1xyXG4gIHByb2R1Y3RzOiBbXSxcclxufSkpO1xyXG5cclxuZGVzY3JpYmUoXCJHZXQgcHJvZHVjdCBieSBJRCAtIGdldFByb2R1Y3RCeUlkXCIsICgpID0+IHtcclxuICBiZWZvcmVFYWNoKCgpID0+IHtcclxuICAgIGplc3QucmVzZXRBbGxNb2NrcygpO1xyXG4gIH0pO1xyXG5cclxuICB0ZXN0KFwic2hvdWxkIHJldHVybiAyMDAgYW5kIHRoZSBwcm9kdWN0IHdoZW4gYSB2YWxpZCBJRCBpcyBwcm92aWRlZFwiLCBhc3luYyAoKSA9PiB7XHJcbiAgICBjb25zdCBtb2NrUHJvZHVjdHMgPSBbeyBpZDogXCIxXCIsIHRpdGxlOiBcIlByb2R1Y3QgMVwiLCBwcmljZTogMTAwIH1dO1xyXG5cclxuICAgIHByb2R1Y3RzLmxlbmd0aCA9IDA7XHJcbiAgICBwcm9kdWN0cy5wdXNoKC4uLm1vY2tQcm9kdWN0cyk7XHJcblxyXG4gICAgY29uc3QgZXZlbnQgPSB7XHJcbiAgICAgIHBhdGhQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgaWQ6IFwiMVwiLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIoZXZlbnQpO1xyXG5cclxuICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXNDb2RlKS50b0JlKDIwMCk7XHJcbiAgICBleHBlY3QocmVzcG9uc2UuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSkudG9CZShcImFwcGxpY2F0aW9uL2pzb25cIik7XHJcbiAgICBleHBlY3QocmVzcG9uc2UuYm9keSkudG9CZShcclxuICAgICAgSlNPTi5zdHJpbmdpZnkoW3sgaWQ6IFwiMVwiLCB0aXRsZTogXCJQcm9kdWN0IDFcIiwgcHJpY2U6IDEwMCB9XSlcclxuICAgICk7XHJcbiAgfSk7XHJcblxyXG4gIHRlc3QoXCJzaG91bGQgcmV0dXJuIDQwMCBpZiBwcm9kdWN0IGlzIG5vdCBmb3VuZFwiLCBhc3luYyAoKSA9PiB7XHJcbiAgICBwcm9kdWN0cy5sZW5ndGggPSAwO1xyXG5cclxuICAgIGNvbnN0IGV2ZW50ID0ge1xyXG4gICAgICBwYXRoUGFyYW1ldGVyczoge1xyXG4gICAgICAgIGlkOiBcIjFcIixcclxuICAgICAgfSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGV2ZW50KTtcclxuXHJcbiAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzQ29kZSkudG9CZSg0MDApO1xyXG4gICAgZXhwZWN0KHJlc3BvbnNlLmhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0pLnRvQmUoXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xyXG4gICAgZXhwZWN0KHJlc3BvbnNlLmJvZHkpLnRvQmUoXHJcbiAgICAgIEpTT04uc3RyaW5naWZ5KHsgbWVzc2FnZTogXCJQcm9kdWN0cyBub3QgZm91bmRcIiB9KVxyXG4gICAgKTtcclxuICB9KTtcclxuXHJcbiAgdGVzdChcInNob3VsZCByZXR1cm4gNDAwIGlmIG5vIHByb2R1Y3RzIGRhdGEgZXhpc3RzXCIsIGFzeW5jICgpID0+IHtcclxuICAgIHByb2R1Y3RzLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgY29uc3QgZXZlbnQgPSB7XHJcbiAgICAgIHBhdGhQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgaWQ6IFwiXCIsXHJcbiAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlcihldmVudCk7XHJcblxyXG4gICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1c0NvZGUpLnRvQmUoNDAwKTtcclxuICAgIGV4cGVjdChyZXNwb25zZS5oZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdKS50b0JlKFwiYXBwbGljYXRpb24vanNvblwiKTtcclxuICAgIGV4cGVjdChyZXNwb25zZS5ib2R5KS50b0JlKFxyXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2U6IFwiUHJvZHVjdHMgbm90IGZvdW5kXCIgfSlcclxuICAgICk7XHJcbiAgfSk7XHJcbn0pO1xyXG4iXX0=